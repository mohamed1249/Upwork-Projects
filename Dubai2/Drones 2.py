###############################################################################
# Written for DEWA Master's in Future Energy Systems and Technology Course 1
# Modeling and Simulation of UAV Swarm Mapping
# Copyright 2021 Tarek Zohdi, Emre Mengi. All rights reserved
###############################################################################
########################## Importing Packages #################################

import numpy as np
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from copy import deepcopy
from matplotlib import animation
from matplotlib import rc
####################### Defining Project Constants ############################

## System Parameters
Nm = 15 # number of initial agents
No = 25 # number of obstacles
Nt = 100 # number of targets to map

## Physical Parameters
Ai = 1 # agent characteristic area (m^2)
Cdi = 0.25 # agent coefficient of drag
mi = 10 # agent mass (kg)
va = [-0.2, 0.2, 0.5] # Air velocity (m/s)
ra = 1.225 # Air Density (kg/m^3)
Fp = 200 # Propolsion force magnitude (N)

## Time Stepping Parameters
dt = 0.2 # time step size (s)
tf = 60 # Maximium task time (s)

## Object Interaction Parameters
agent_sight = 5 # maximum target mapping distance
crash_range = 2 # agent collision distance

## Genetic Algorithm Parameters
K = 6 # Strings generated by breeding
P = 6 # Surviving strings for breeding
S = 20 # Design strings per generation
G = 100 # Total Generations
minLam = 0. # Minimum value of design strings
maxLam = 2. # Maximum value of design strings
numLam = 15

w1 = 70 # Weight of mapping in net cost
w2 = 10 # Weight of time usage in net cost
w3 = 20 # Weight of agent losses in net cost

## Domain Parameters
xmax = 150 # x bound of domain
ymax = 150 # y bound of domain
zmax = 60 # z bound of domain

locx = 100 # x bound of target/obstacle region 
locy = 100 # y bound of target/obstacle region 
locz = 10 # z bound of target/obstacle region 

## Initial Target, Obstacle, Agent Positions
obs = np.array([(locx - (-locx))*np.random.rand(No) + (-locx), (locy - (-locy))*np.random.rand(No) + (-locy),
       (locz - (-locz))*np.random.rand(No) + (-locz)]) # Initial Obstacle Locations

obs = obs.T

tar = np.array([(locx - (-locx))*np.random.rand(Nt) + (-locx), (locy - (-locy))*np.random.rand(Nt) + (-locy),
       (locz - (-locz))*np.random.rand(Nt) + (-locz)]) # Initial Target Locations

tar = tar.T
tar0 = deepcopy(np.array(tar))
pos = np.array([(xmax - 0.05*xmax)*np.ones(Nm), np.linspace(-ymax + 0.05*ymax, ymax - 0.05*ymax, Nm), 
          np.zeros(Nm)]) # Initial Agent Location

pos = pos.T

pos0 = deepcopy(np.array(pos))

vel = np.zeros([Nm,3]) # Initial Agent velocities
vel0 = np.zeros([Nm,3])
###############################################################################
############################## Plotting Initial System ########################

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(obs[:,0],obs[:,1],obs[:,2],color = 'r')
ax.scatter(tar[:,0],tar[:,1],tar[:,2],color = 'g')
ax.scatter(pos[:,0],pos[:,1],pos[:,2],color = 'k')
ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_zlabel('Z (m)')
ax.view_init(elev=70., azim=40)
ax.legend(['Obstacles','Targets','Agents'])
################################## Drone Simulation Function ####################################################

def droneSim(Nm,No,Nt,w1,w2,w3,Lam,dt,tf,pos,vel,tar,obs):

    Nt0 = Nt # Saving initial number of targets for cost calculation
    Nm0 = Nm # Saving initial number of agents for cost calculation
    
    # Assigning design string to associated variables   
    Wmt = Lam[0] 
    Wmo = Lam[1] 
    Wmm = Lam[2] 

    wt1 = Lam[3]
    wt2 = Lam[4]
    
    wo1 = Lam[5]  
    wo2 = Lam[6]
    
    wm1 = Lam[7]  
    wm2 = Lam[8]
    
    a1 = Lam[9]
    a2 = Lam[10] 

    b1 = Lam[11]
    b2 = Lam[12]

    c1 = Lam[13]
    c2 = Lam[14]


    ts = int(np.ceil(tf/dt)) # Max Number of time steps

    c = 0 # counter for actual number of time steps

    # Initialize agent and target position arrays for plotting
    posTot = list()
    tarTot = list()

    posTot.append(deepcopy(np.array(pos))) # array to save all positions of agents at every time step
    tarTot.append(deepcopy(np.array(tar))) # array to save all positions of agents at every time step

    for i in range(ts): # Loop through all time
        
        if Nt <= 0 or Nm <= 0: # If all targets or agents have crashed, stop simulating
            break

        c = c + 1 # Keep track of time step

        # Initialize distance arrays between targets, agents, and obstacles
        dmt = np.array(np.zeros((3,Nm,Nt)))
        dmm = np.array(np.zeros((3,Nm,Nm)))
        dmo = np.array(np.zeros((3,Nm,No)))


        # Loop through agents
        for j in range(Nm):
                        
            dmt[:,j,:] = np.array((tar - pos[j,:]).T) # distance b/w agent j and all targets

            dmm[:,j,:] = np.array((pos - pos[j,:]).T) # distance b/w agent j and all other agents
            
            dmm[:,j,j] = float('inf') # Marker so we are not considering distance between agent and itself

            dmo[:,j,:] = np.array((obs - pos[j,:]).T) # distance b/w agent j and all obstacles


        # Calculate magnitude of distances between all objects
        magdmt = np.array(np.linalg.norm(dmt,2,0))
        magdmm = np.array(np.linalg.norm(dmm,2,0))
        magdmo = np.array(np.linalg.norm(dmo,2,0))

        # Determine which targets have been mapped
        tar_map = np.array(np.where(magdmt < agent_sight)) #produces 2 1-D arrays: 1st array:row, 2nd array:column

        # Determined which agents have crashed into one another
        mm_crash = np.array(np.where(magdmm < crash_range))

        # Determine which agents have crashed into obstacles
        mo_crash = np.array(np.where(magdmo < crash_range))

        # Determine which agents have moved outside domain in each dimension
        x_crash = np.array(np.where(np.abs(pos[:,0]) > xmax))
        y_crash = np.array(np.where(np.abs(pos[:,1]) > ymax))
        z_crash = np.array(np.where(np.abs(pos[:,2]) > zmax))

        # Combine all domain crashes together (unique since there could be overlap)
        dom_crash = np.unique(np.hstack((x_crash[0,:], y_crash[0,:], z_crash[0,:])))

        # Generate index arrays to determine which targets to remove and which agents to remove
        tarRem = np.array(np.unique(tar_map[1,:])) #access the column indices for tar_map --> target indices
        ageRem = np.unique(np.hstack([mm_crash[0,:], mo_crash[0,:], dom_crash])) #access the row indices for mm/mo --> agent/obstacle indices
        
        # use -inf as marker to distinguish between agent j-j marker and remove agent marker
        magdmm[magdmm == float('inf')] = float('-inf')
        dmm[dmm == float('inf')] = float('-inf')

        if (tarRem.size > 0 or ageRem.size > 0): # Only remove objects if targets mapped or agents crash

            # Determine new number of targets and new number of agents
            Nt = Nt - np.size(tarRem)
            Nm = Nm - np.size(ageRem)
            
            if Nt <= 0 or Nm <= 0: # If all targets or agents have crashed, stop simulating
                break
  
            if tarRem.size > 0: # If statement for target mapping
            
                # Use +inf as remove target marker
                magdmt[:,tarRem] = float('inf')
                dmt[:,:,tarRem] = float('inf')
                tar[tarRem,:] = float('inf')
                
            if ageRem.size > 0:
                
                # Use +inf as remove agent marker
                magdmt[ageRem,:] = float('inf')
                dmt[:,ageRem,:] = float('inf')
                magdmm[ageRem,:] = float('inf')
                magdmm[:,ageRem] = float('inf')
                dmm[:,ageRem,:] = float('inf')
                dmm[:,:,ageRem] = float('inf')
                magdmo[ageRem,:] = float('inf')
                dmo[:,ageRem,:] = float('inf')
                pos[ageRem,:] = float('inf')
                vel[ageRem,:] = float('inf')

            # Remove and reshape arrays to account for removal of all targets and agents
            magdmt = np.array(np.reshape(magdmt[magdmt != float('inf')],[Nm,Nt]))
            dmt = np.array(np.reshape(dmt[dmt != float('inf')],[3,Nm,Nt]))
            magdmo = np.array(np.reshape(magdmo[magdmo != float('inf')],[Nm,No]))
            dmo = np.array(np.reshape(dmo[dmo != float('inf')],[3,Nm,No]))
            magdmm = np.array(np.reshape(magdmm[magdmm != float('inf')],[Nm,Nm]))
            dmm = np.array(np.reshape(dmm[dmm != float('inf')],[3,Nm,Nm]))
            pos = np.array(np.reshape(pos[pos != float('inf')],[Nm,3]))
            vel = np.array(np.reshape(vel[vel != float('inf')],[Nm,3]))
            tar = np.array(np.reshape(tar[tar != float('inf')],[Nt,3]))

        tarTot.append(tar[:]) # save new target positions
        
        # Remove and reshape array for j-j agent interactions which we ignore 
        magdmm = np.array(np.reshape(magdmm[magdmm != float('-inf')],[Nm,Nm-1]))
        dmm = np.array(dmm[dmm != float('-inf')])
        dmm = np.reshape(dmm,[3,Nm,Nm-1])

        # Calculate unit normal vector between all objects
        nmt = dmt / magdmt[np.newaxis,:,:]
        nmm = dmm / magdmm[np.newaxis,:,:]
        nmo = dmo / magdmo[np.newaxis,:,:]

        
        # Calculate scaled direction vectors between objects
        nhatmt = (wt1*np.exp(-a1*magdmt) - wt2*np.exp(-a2*magdmt))
        nhatmt = nhatmt[np.newaxis,:,:]*nmt

        nhatmm = (wm1*np.exp(-c1*magdmm) - wm2*np.exp(-c2*magdmm))
        nhatmm = nhatmm[np.newaxis,:,:]*nmm

        nhatmo = (wo1*np.exp(-b1*magdmo) - wo2*np.exp(-b2*magdmo))
        nhatmo = nhatmo[np.newaxis,:,:]*nmo

        # Sum up all iteraction vectors for each agent
        Nmt = np.sum(nhatmt,2)
        Nmm = np.sum(nhatmm,2)
        Nmo = np.sum(nhatmo,2)

        # Calculate the total force vectors for each agent
        Ntot = (Wmt*Nmt.T + Wmm *Nmm.T + Wmo*Nmo.T)

        # Obtain magnitude of force vector
        nDum = np.linalg.norm(Ntot,2,1)

        # Normalize force vector for each agent
        nstar = Ntot / nDum[:,np.newaxis]

        # Calculate drag force on all agents
        Fd = 0.5*ra*Cdi*Ai*((va-vel).T*np.linalg.norm(va - vel,2,1)).T

        # Calculate the total force on all agents
        Ftot = Fp*nstar + Fd

        # Update the velocity for each agent using forward euler
        vel += dt*Ftot/mi

        # Update the position for each agent using forward euler
        pos += (vel*dt)

        # Save the position of each agent
        posTot.append(pos[:])
     
    # Calculate Mstar, Tstar, Lstar for cost calculation
    Mstar = (Nt/Nt0)
    Tstar = ((c*dt)/tf)
    Lstar = ((Nm0 - Nm)/Nm0)
      
    # Calculate the cost for this simulation
    Pi = w1*Mstar + w2*Tstar + w3*Lstar
    
    return(Pi, posTot, tarTot, c, Mstar,Tstar,Lstar)
################################# Genetic Algorithm Function #######################################################

def myGA(S,G,P,K,minLam,maxLam,numLam,Nm,No,Nt,w1,w2,w3,dt,tf,pos,vel):
    
    # Initialize all variables to be saved
    Min = np.zeros(G) # Minimum cost for each generation
    PAve = np.zeros(G) # Parent average for each generation
    Ave = np.zeros(G) # Total population average for each generation
    
    Pi = np.zeros(S) # All costs in an individual generation
    Mstar = np.zeros(S) # All Mstar values in each generation
    Tstar = np.zeros(S) # All Tstar values in each generation
    Lstar = np.zeros(S) # All Lstar values in each generation
    
    MstarMin = np.zeros(G) # Mstar value associated with best cost for each generation
    TstarMin = np.zeros(G) # Tstar value associated with best cost for each generation
    LstarMin = np.zeros(G) # Lstar value associated with best cost for each generation
    
    MstarPAve = np.zeros(G) # Average Mstar value for top parents for each generation
    TstarPAve = np.zeros(G) # Average Tstar value for top parents for each generation
    LstarPAve = np.zeros(G) # Average Lstar value for top parents for each generation
    
    MstarAve = np.zeros(G) # Average Mstar value for whole population for each generation
    TstarAve = np.zeros(G) # Average Tstar value for whole population for each generation
    LstarAve = np.zeros(G) # Average Lstar value for whole population for each generation
    
    # Generate initial random population
    Lam = (maxLam - minLam)*np.random.rand(numLam,S) + minLam
    
    # Initially, calculate cost for all strings. After, only calculate new strings since top P already calculated
    start = 0 
    
    for i in range(G): # Loop through generations
        
        # Calculate fitness of unknown design string costs
        for j in range(start,S): # Evaluate fitness of strings
            Pi[j], _, _, _, Mstar[j], Tstar[j], Lstar[j] = droneSim(Nm,No,Nt,w1,w2,w3,Lam[:,j],dt,tf,pos,vel,tar,obs)
            
        
        # Sort cost and design strings based on performance
        ind = np.argsort(Pi)
        Pi = np.sort(Pi)
        Lam = Lam[:,ind]
        Mstar = Mstar[ind]
        Tstar = Tstar[ind]
        Lstar = Lstar[ind]
        
        # Generate offspring radnom parameters and indices for vectorized offspring calculation
        phi = np.random.rand(numLam,K)
        ind1 = range(0,K,2)
        ind2 = range(1,K,2)
             
        # Concatonate original parents children, and new random strings all together into new design string array
        Lam = np.hstack((Lam[:,0:P], phi[:,ind1]*Lam[:,ind1] + (1-phi[:,ind1])*Lam[:,ind2],
                      phi[:,ind2]*Lam[:,ind2] + (1-phi[:,ind2])*Lam[:,ind1], 
                    (maxLam - minLam)*np.random.rand(numLam,S-P-K) + minLam));
        
        # Save all requested values
        Min[i] = Pi[0]
        PAve[i] = np.mean(Pi[0:P])
        Ave[i] = np.mean(Pi)
        
        MstarMin[i] = Mstar[0]
        TstarMin[i] = Tstar[0]
        LstarMin[i] = Lstar[0]
        
        MstarPAve[i] = np.mean(Mstar[0:P])
        TstarPAve[i] = np.mean(Tstar[0:P])
        LstarPAve[i] = np.mean(Lstar[0:P])
        
        MstarAve[i] = np.mean(Mstar)
        TstarAve[i] = np.mean(Tstar)
        LstarAve[i] = np.mean(Lstar)
        
        # Update start to P such that only new string cost values are calculated
        start = P
        
        # Print miminum value of cost for debugging (should monotonically decrease over generations)
        print(Min[i])
        
    return(Lam, Pi, Min, PAve, Ave, MstarMin, TstarMin, LstarMin, MstarPAve, TstarPAve, LstarPAve, 
           MstarAve, TstarAve, LstarAve)

# Call GA function
Lam, Pi, Min, PAve, Ave, MstarMin, TstarMin, LstarMin, MstarPAve, TstarPAve, LstarPAve, MstarAve, TstarAve, LstarAve= myGA(S,G,P,K,minLam,maxLam,numLam,Nm,No,Nt,w1,w2,w3,dt,tf,pos,vel)
fig1 = plt.figure(figsize=(12,5))
plt.semilogy(range(0,G),Min)
plt.semilogy(range(0,G),PAve)
plt.semilogy(range(0,G),Ave)
plt.xlabel('Generation')
plt.ylabel('Min or Ave cost')
plt.title('Cost Evolution')
plt.legend(['Best Cost', 'Average Parent Cost','Average Cost'])
plt.show()

fig2 = plt.figure(figsize=(12,5))
plt.plot(range(0,G),MstarMin)
plt.plot(range(0,G),TstarMin)
plt.plot(range(0,G),LstarMin)
plt.xlabel('Generation')
plt.ylabel('Cost Parameter Value')
plt.title('Best Cost Parameter Evolution')
plt.legend(['M*', 'T*','L*'])
plt.show()

fig3 = plt.figure(figsize=(12,5))
plt.plot(range(0,G),MstarPAve)
plt.plot(range(0,G),TstarPAve)
plt.plot(range(0,G),LstarPAve)
plt.xlabel('Generation')
plt.ylabel('Cost Parameter Value')
plt.title('Parent Average Cost Parameter Evolution')
plt.legend(['M*', 'T*','L*'])
plt.show()

fig4 = plt.figure(figsize=(12,5))
plt.plot(range(0,G),MstarAve)
plt.plot(range(0,G),TstarAve)
plt.plot(range(0,G),LstarAve)
plt.xlabel('Generation')
plt.ylabel('Cost Parameter Value')
plt.title('Population Average Cost Parameter Evolution')
plt.legend(['M*', 'T*','L*'])
plt.show()
################################# Plotting Best Solution ###############################################################
for i in range(4):
    print([i+1, Lam[:, i].T, Pi[i]])